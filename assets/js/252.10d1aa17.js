(window.webpackJsonp=window.webpackJsonp||[]).push([[252],{698:function(e,a,t){"use strict";t.r(a);var r=t(1),o=Object(r.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"overview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),a("p",{attrs:{synopsis:""}},[e._v("Learn how to manage chain upgrades for your full and validator nodes.")]),e._v(" "),a("h2",{attrs:{id:"upgrade-categories"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#upgrade-categories"}},[e._v("#")]),e._v(" Upgrade Categories")]),e._v(" "),a("p",[e._v("There are 3 different categories for upgrades:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Planned or Unplanned Upgrades")]),e._v(": Chain upgrades can be scheduled at a given height through an upgrade proposal plan.")]),e._v(" "),a("li",[a("strong",[e._v("Breaking or Non-breaking Upgrades")]),e._v(": Upgrades can be API or State Machine breaking, which affects backwards compatibility. To address this, the application state or genesis file would need to be migrated in preparation for the upgrade.")]),e._v(" "),a("li",[a("strong",[e._v("Data Reset Upgrades")]),e._v(": Some upgrades will need a full data reset in order to clean the state. This can sometimes occur in the case of a rollback or hard fork.")])]),e._v(" "),a("p",[e._v("Additionally, validators can choose how to manage the upgrade according to their preferred option:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Automatic or Manual Upgrades")]),e._v(": Validator can run the "),a("code",[e._v("cosmovisor")]),e._v(" process to automatically perform the upgrade or do it manually.")])]),e._v(" "),a("h2",{attrs:{id:"planned-upgrades"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#planned-upgrades"}},[e._v("#")]),e._v(" Planned Upgrades")]),e._v(" "),a("p",[e._v("Planned upgrades are coordinated scheduled upgrades that use the "),a("a",{attrs:{href:"https://docs.planq.network/modules/upgrade/",target:"_blank",rel:"noopener noreferrer"}},[e._v("upgrade module"),a("OutboundLink")],1),e._v(" logic. This facilitates smoothly upgrading Planq to a new (breaking) software version as it automatically handles the state migration for the new release.")]),e._v(" "),a("h3",{attrs:{id:"governance-proposal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#governance-proposal"}},[e._v("#")]),e._v(" Governance Proposal")]),e._v(" "),a("p",[e._v("Governance Proposals are a mechanism for coordinating an upgrade at a given height or time using an "),a("a",{attrs:{href:"https://docs.planq.network/modules/upgrade/01_concepts.html#proposal",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("SoftwareProposal")]),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[e._v("All governance proposals, including software upgrades, need to wait for the voting period to conclude before the upgrade can be executed. Consider this duration when submitting a software upgrade proposal.")])]),e._v(" "),a("p",[e._v("If the proposal passes, the upgrade "),a("code",[e._v("Plan")]),e._v(", which targets a specific upgrade logic to migrate the state, is persisted to the blockchain state and scheduled at the given upgrade height. The upgrade can be delayed or expedited by updating the "),a("code",[e._v("Plan.Height")]),e._v(" in a new proposal.")]),e._v(" "),a("h3",{attrs:{id:"hard-forks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hard-forks"}},[e._v("#")]),e._v(" Hard Forks")]),e._v(" "),a("p",[e._v("A special type of planned upgrades are "),a("RouterLink",{attrs:{to:"/validators/upgrades/hard_fork.html"}},[e._v("hard forks")]),e._v(". Hard Forks, as opposed to Governance Proposal, don't require waiting for the full voting\nperiod. This makes them ideal for coordinating security vulnerabilities and patches.")],1),e._v(" "),a("p",[e._v("The upgrade (fork) block height is set in the "),a("code",[e._v("BeginBlock")]),e._v(" of the application (i.e before the transactions are processed for the block). Once the blockchain reaches that height, it automatically schedules an upgrade "),a("code",[e._v("Plan")]),e._v(" for the same height and then triggers the upgrade process. After upgrading, the block operations ("),a("code",[e._v("BeginBlock")]),e._v(", transaction processing and state "),a("code",[e._v("Commit")]),e._v(") continue normally.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[e._v("In order to execute an upgrade hard fork, a "),a("a",{attrs:{href:"#patch-versions"}},[e._v("patch version")]),e._v(" needs to first be released with the "),a("code",[e._v("BeginBlock")]),e._v(" upgrade scheduling logic. After a +2/3 of the validators upgrade to the new patch version, their nodes will automatically halt and upgrade the binary.")])]),e._v(" "),a("h2",{attrs:{id:"unplanned-upgrades"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unplanned-upgrades"}},[e._v("#")]),e._v(" Unplanned Upgrades")]),e._v(" "),a("p",[e._v("Unplanned upgrades are upgrades where all the validators need to gracefully halt and shut down their nodes at exactly the same point in the process. This can be done by setting the "),a("code",[e._v("--halt-height")]),e._v(" flag when running the "),a("code",[e._v("planqd start")]),e._v(" command.")]),e._v(" "),a("p",[e._v("If there are breaking changes during an unplanned upgrade (see below), validators will need to migrate the state and genesis before restarting their nodes.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[e._v("The main consideration with unplanned upgrades is that the genesis state needs to be exported and the blockchain data needs to be "),a("a",{attrs:{href:"#data-reset-upgrades"}},[e._v("reset")]),e._v(". This mainly affects infrastructure providers, tools and clients like block explorers and clients, which have to use archival nodes to serve queries for the pre-upgrade heights.")])]),e._v(" "),a("h2",{attrs:{id:"breaking-and-non-breaking-upgrades"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#breaking-and-non-breaking-upgrades"}},[e._v("#")]),e._v(" Breaking and Non-Breaking Upgrades")]),e._v(" "),a("p",[e._v("Upgrades can be categorized as breaking or non-breaking according to the Semantic versioning ("),a("a",{attrs:{href:"https://semver.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Semver"),a("OutboundLink")],1),e._v(") of the corresponding software "),a("a",{attrs:{href:"https://github.com/planq-network/planq/releases",target:"_blank",rel:"noopener noreferrer"}},[e._v("release version"),a("OutboundLink")],1),e._v(" ("),a("em",[e._v("i.e")]),e._v(" "),a("code",[e._v("vX.Y.Z")]),e._v("):")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Major version ("),a("code",[e._v("X")]),e._v(")")]),e._v(": backward incompatible API and state machine breaking changes.")]),e._v(" "),a("li",[a("strong",[e._v("Minor version ("),a("code",[e._v("Y")]),e._v(")")]),e._v(": new backward compatible features. These can be also be state machine breaking.")]),e._v(" "),a("li",[a("strong",[e._v("Patch version ("),a("code",[e._v("Z")]),e._v(")")]),e._v(": backwards compatible bug fixes, small refactors and improvements.")])]),e._v(" "),a("h3",{attrs:{id:"major-versions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#major-versions"}},[e._v("#")]),e._v(" Major Versions")]),e._v(" "),a("p",[e._v("If the new version you are upgrading to has breaking changes, you will have to:")]),e._v(" "),a("ol",[a("li",[e._v("Migrate genesis JSON")]),e._v(" "),a("li",[e._v("Migrate application state")]),e._v(" "),a("li",[e._v("Restart node")])]),e._v(" "),a("p",[e._v("This needs to be done to prevent "),a("a",{attrs:{href:"https://docs.tendermint.com/master/spec/consensus/signing.html#double-signing",target:"_blank",rel:"noopener noreferrer"}},[e._v("double signing or halting the chain during consensus"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[e._v("To upgrade the genesis file, you can either fetch it from a trusted source or export it locally using the "),a("code",[e._v("planqd export")]),e._v(" command.")]),e._v(" "),a("h3",{attrs:{id:"minor-versions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#minor-versions"}},[e._v("#")]),e._v(" Minor Versions")]),e._v(" "),a("p",[e._v("If the new version you are upgrading to has breaking changes, you will have to:")]),e._v(" "),a("ol",[a("li",[e._v("Migrate the state (if applicable)")]),e._v(" "),a("li",[e._v("Restart node")])]),e._v(" "),a("h3",{attrs:{id:"patch-versions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#patch-versions"}},[e._v("#")]),e._v(" Patch Versions")]),e._v(" "),a("p",[e._v("In order to update a patch:")]),e._v(" "),a("ol",[a("li",[e._v("Stop Node")]),e._v(" "),a("li",[e._v("Download new release binary manually")]),e._v(" "),a("li",[e._v("Restart node")])]),e._v(" "),a("h2",{attrs:{id:"data-reset-upgrades"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-reset-upgrades"}},[e._v("#")]),e._v(" Data Reset Upgrades")]),e._v(" "),a("p",[e._v("Data Reset upgrades require node operators to fully reset the blockchain state and restart their nodes from a clean\nstate, but using the same validator keys.")]),e._v(" "),a("h2",{attrs:{id:"automatic-or-manual-upgrades"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#automatic-or-manual-upgrades"}},[e._v("#")]),e._v(" Automatic or Manual Upgrades")]),e._v(" "),a("p",[e._v("With every new software release, we strongly recommend full nodes and validator operators to perform a software upgrade.")]),e._v(" "),a("p",[e._v("You can upgrade your node by either:")]),e._v(" "),a("ul",[a("li",[a("RouterLink",{attrs:{to:"/validators/upgrades/automated.html"}},[e._v("automatically")]),e._v(" bumping the software version and restart the node once the upgrade occurs, or")],1),e._v(" "),a("li",[e._v("download the new binary and perform a "),a("RouterLink",{attrs:{to:"/validators/upgrades/manual.html"}},[e._v("manual upgrade")])],1)]),e._v(" "),a("p",[e._v("Follow the links in the options above to learn how to upgrade your node according to your preferred option.")])])}),[],!1,null,null,null);a.default=o.exports}}]);